<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>究極オセロAI（最終修正版）</title>
    <style>
        /* CSSは変更なし */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            background-color: #f4f4f9;
            padding-top: 20px;
        }
        h1 {
            color: #333;
        }
        #status {
            margin: 15px 0;
            font-size: 1.2em;
            font-weight: bold;
        }
        #board {
            border-collapse: collapse;
            margin: 20px auto;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
        }
        #board td {
            width: 60px;
            height: 60px;
            border: 1px solid #333;
            background-color: #008000;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        #board td:hover {
            background-color: #00a000;
        }
        .piece {
            display: inline-block;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: transform 0.3s ease-out;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
        .black {
            background-color: black;
        }
        .white {
            background-color: white;
        }
        .highlight {
            background-color: rgba(255, 255, 0, 0.4) !important;
        }
        #learning-info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0e68c;
            border-radius: 5px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h1>究極オセロAI デモ (ID + TT + $\alpha-\beta$ 探索)</h1>
    <div id="status">システム初期化中...</div>
    <div id="learning-info">AIが**100回**の自己対戦で学習中です...</div>
    <table id="board">
        </table>
    
    <script>
        // ------------------------------------------------
        // グローバル定数と変数
        // ------------------------------------------------
        const BOARD_SIZE = 8;
        const BLACK = 1;
        const WHITE = 2;
        const EMPTY = 0;
        
        // AIの思考時間制限 (ミリ秒) - 対戦モードのみ適用
        const TIME_LIMIT = 5000; 
        
        let transpositionTable = new Map();
        
        let board;
        let currentPlayer;
        let isGameActive = false;
        let isAITurn = false;
        let startTime; 
        let bestMoveInSearch = null; 
        
        const statusElement = document.getElementById('status');
        const boardElement = document.getElementById('board');
        const learningInfoElement = document.getElementById('learning-info');

        let evaluationWeights = [
            [ 100, -20,  10,   5,   5,  10, -20, 100],
            [-20,  -50,  -2,  -2,  -2,  -2, -50, -20],
            [ 10,   -2,   1,   1,   1,   1,  -2,  10],
            [  5,   -2,   1,   0,   0,   1,  -2,   5],
            [  5,   -2,   1,   0,   0,   1,  -2,   5],
            [ 10,   -2,   1,   1,   1,   1,  -2,  10],
            [-20,  -50,  -2,  -2,  -2,  -2, -50, -20],
            [ 100, -20,  10,   5,   5,  10, -20, 100]
        ];

        const DIRECTIONS = [
            [-1, 0], [-1, 1], [0, 1], [1, 1],
            [1, 0], [1, -1], [0, -1], [-1, -1]
        ];

        // ------------------------------------------------
        // ユーティリティ & 基本ゲームロジック
        // ------------------------------------------------
        
        function copyBoard(b) {
            return b.map(row => [...row]);
        }
        
        function getBoardHash(boardState) {
            return boardState.flat().join('');
        }
        
        function getFlippableDiscs(boardState, r, c, player) {
            const opponent = 3 - player;
            let flippable = [];

            if (boardState[r][c] !== EMPTY) return []; 

            for (const [dr, dc] of DIRECTIONS) {
                let currentFlippable = [];
                let cr = r + dr;
                let cc = c + dc;

                while (cr >= 0 && cr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE && boardState[cr][cc] === opponent) {
                    currentFlippable.push({ r: cr, c: cc });
                    cr += dr;
                    cc += dc;
                }

                if (cr >= 0 && cr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE && boardState[cr][cc] === player) {
                    flippable = flippable.concat(currentFlippable);
                }
            }
            return flippable;
        }

        function checkValidMove(boardState, r, c, player) {
            if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || boardState[r][c] !== EMPTY) {
                return false;
            }
            return getFlippableDiscs(boardState, r, c, player).length > 0;
        }

        function doMove(r, c, player, currentBoard = board) {
            const flippable = getFlippableDiscs(currentBoard, r, c, player);
            if (flippable.length === 0) return false;

            currentBoard[r][c] = player;
            for (const disc of flippable) {
                currentBoard[disc.r][disc.c] = player;
            }
            return true;
        }
        
        function getValidMoves(boardState, player) {
            let moves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (checkValidMove(boardState, r, c, player)) {
                        moves.push({ r: r, c: c });
                    }
                }
            }
            return moves;
        }
        
        function isGameOver(boardState) {
            return getValidMoves(boardState, BLACK).length === 0 && getValidMoves(boardState, WHITE).length === 0;
        }

        function getWinner(boardState) {
            let blackCount = boardState.flat().filter(p => p === BLACK).length;
            let whiteCount = boardState.flat().filter(p => p === WHITE).length;
            
            if (blackCount > whiteCount) return BLACK;
            if (whiteCount > blackCount) return WHITE;
            return EMPTY;
        }

        // ------------------------------------------------
        // 評価関数
        // ------------------------------------------------

        function evaluateBoard(currentBoard, player) {
            const opponent = 3 - player;
            let score = 0;
            let totalPieces = 0;
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== EMPTY) {
                        totalPieces++;
                    }
                }
            }
            
            let phaseWeight = totalPieces < 50 ? 1 : 50; 

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === player) {
                        score += evaluationWeights[r][c];
                    } else if (currentBoard[r][c] === opponent) {
                        score -= evaluationWeights[r][c];
                    }
                }
            }
            
            const playerMoves = getValidMoves(currentBoard, player).length;
            const opponentMoves = getValidMoves(currentBoard, opponent).length;
            score += 20 * (playerMoves - opponentMoves); 

            const playerPieces = currentBoard.flat().filter(p => p === player).length;
            const opponentPieces = currentBoard.flat().filter(p => p === opponent).length;
            score += phaseWeight * (playerPieces - opponentPieces); 

            return score;
        }

        // ------------------------------------------------
        // AIロジック: MiniMax with Alpha-Beta Pruning & Transposition Table
        // ------------------------------------------------

        function minimax(boardState, depth, alpha, beta, maximizingPlayer) {
            // **時間切れチェック（再帰の最上部）**
            if (performance.now() - startTime > TIME_LIMIT) {
                return maximizingPlayer ? Infinity : -Infinity;
            }

            const player = maximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMoves(boardState, player);

            if (depth === 0 || isGameOver(boardState) || validMoves.length === 0) {
                return evaluateBoard(boardState, WHITE);
            }
            
            const hash = getBoardHash(boardState);
            const entry = transpositionTable.get(hash);
            if (entry && entry.depth >= depth) {
                if (entry.flag === 'EXACT') return entry.score;
                if (entry.flag === 'LOWER' && entry.score > alpha) alpha = entry.score;
                if (entry.flag === 'UPPER' && entry.score < beta) beta = entry.score;
                if (alpha >= beta) return entry.score;
            }

            let bestScore = maximizingPlayer ? -Infinity : Infinity;
            let flag = 'UPPER';

            for (const move of validMoves) {
                const nextBoard = copyBoard(boardState);
                doMove(move.r, move.c, player, nextBoard);
                
                const evaluation = minimax(nextBoard, depth - 1, alpha, beta, !maximizingPlayer);

                // minimaxからの戻り値が時間切れフラグの場合
                if (Math.abs(evaluation) === Infinity) return evaluation;

                if (maximizingPlayer) {
                    bestScore = Math.max(bestScore, evaluation);
                    alpha = Math.max(alpha, bestScore);
                } else {
                    bestScore = Math.min(bestScore, evaluation);
                    beta = Math.min(beta, bestScore);
                }

                if (beta <= alpha) {
                    flag = maximizingPlayer ? 'LOWER' : 'UPPER';
                    break;
                }
            }
            
            if (bestScore > alpha && bestScore < beta) {
                flag = 'EXACT';
            }

            transpositionTable.set(hash, {
                depth: depth,
                score: bestScore,
                flag: flag
            });

            return bestScore;
        }

        /** AIの最善手を選択 (学習モード/対戦モードの分岐あり) */
        function getBestMove(currentBoard, player, isLearningMode = false) {
            let validMoves = getValidMoves(currentBoard, player);
            if (validMoves.length === 0) return null;

            if (isLearningMode) {
                // 【学習モード】高速な貪欲法 (1手先読み)
                let bestScore = -Infinity;
                let bestMove = validMoves[0];
                
                for (const move of validMoves) {
                    const nextBoard = copyBoard(currentBoard);
                    doMove(move.r, move.c, player, nextBoard);
                    const score = evaluateBoard(nextBoard, player); 

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return bestMove;

            } else {
                // 【対戦モード】本格的な反復深化と時間制限探索
                startTime = performance.now();
                bestMoveInSearch = validMoves[0]; 

                transpositionTable.clear();

                for (let depth = 1; ; depth++) {
                    
                    // ★★★ 修正1: 反復深化の開始時にも時間切れをチェック ★★★
                    if (performance.now() - startTime > TIME_LIMIT) {
                        console.log(`深さ ${depth} 探索開始前に時間切れ。`);
                        return bestMoveInSearch;
                    }

                    let currentBestScore = -Infinity;
                    let currentBestMove = null;
                    const maximizingPlayer = (player === WHITE);

                    // MiniMaxの第1層
                    for (const move of validMoves) {
                        
                        // ★★★ 修正2: 各手の探索前にも時間切れをチェック ★★★
                        if (performance.now() - startTime > TIME_LIMIT) {
                            console.log(`深さ ${depth} 探索中に時間切れ。`);
                            return bestMoveInSearch;
                        }
                        
                        const nextBoard = copyBoard(currentBoard);
                        doMove(move.r, move.c, player, nextBoard);

                        const score = minimax(nextBoard, depth - 1, -Infinity, Infinity, !maximizingPlayer);

                        // ★★★ 修正3: minimaxからの時間切れフラグをチェック ★★★
                        if (Math.abs(score) === Infinity) {
                            console.log(`深さ ${depth} の再帰呼び出し中に時間切れ。`);
                            return bestMoveInSearch;
                        }

                        if (score > currentBestScore) {
                            currentBestScore = score;
                            currentBestMove = move;
                        }
                    }

                    if (currentBestMove) {
                        bestMoveInSearch = currentBestMove;
                        console.log(`深さ ${depth} 探索完了。スコア: ${currentBestScore.toFixed(2)}`);
                    } else {
                        break;
                    }

                    if (isGameOver(currentBoard)) {
                         break;
                    }
                }
                return bestMoveInSearch;
            }
        }


        // ------------------------------------------------
        // 初期化、描画、ターン管理
        // ------------------------------------------------

        function drawBoard(highlightMoves = true) {
            boardElement.innerHTML = '';
            const validMoves = getValidMoves(board, currentPlayer);

            for (let r = 0; r < BOARD_SIZE; r++) {
                const row = boardElement.insertRow(r);
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = row.insertCell(c);
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    if (board[r][c] === BLACK) {
                        cell.innerHTML = '<span class="piece black"></span>';
                    } else if (board[r][c] === WHITE) {
                        cell.innerHTML = '<span class="piece white"></span>';
                    } else {
                        cell.innerHTML = '';
                    }

                    const isValid = validMoves.some(m => m.r === r && m.c === c);
                    
                    if (isGameActive && currentPlayer === BLACK && !isAITurn && isValid) {
                        if (highlightMoves) {
                            cell.classList.add('highlight');
                        }
                        cell.onclick = () => handleMove(r, c); 
                    } else {
                        cell.onclick = null; 
                        cell.classList.remove('highlight');
                    }
                }
            }
        }

        function updateStatus() {
            const validMoves = getValidMoves(board, currentPlayer);
            let blackCount = board.flat().filter(p => p === BLACK).length;
            let whiteCount = board.flat().filter(p => p === WHITE).length;
            
            let statusText = `黒 (${blackCount}) vs 白 (${whiteCount}) | `;

            if (isGameOver(board)) {
                isGameActive = false;
                const winner = getWinner(board);
                if (winner === BLACK) statusText += 'ゲーム終了: **黒**の勝利！';
                else if (winner === WHITE) statusText += 'ゲーム終了: **白**（AI）の勝利！';
                else statusText += 'ゲーム終了: **引き分け**！';
            } else if (validMoves.length === 0) {
                statusText += `${currentPlayer === BLACK ? '黒' : '白'}は置ける場所がないため**パス**します。`;
                setTimeout(() => {
                    currentPlayer = 3 - currentPlayer;
                    checkTurn();
                }, 500);
            } else {
                statusText += `${currentPlayer === BLACK ? '黒' : '白'}の番です。`;
            }

            statusElement.innerHTML = statusText;
        }

        function checkTurn() {
            if (!isGameActive) return;

            if (currentPlayer === WHITE) {
                isAITurn = true;
                drawBoard(false);
                statusElement.innerHTML = `黒 vs 白 | **白 (AI)** が思考中... (制限時間 ${TIME_LIMIT/1000}秒)`;
                
                setTimeout(() => {
                    const bestMove = getBestMove(board, WHITE, false);

                    if (bestMove) {
                        handleMove(bestMove.r, bestMove.c);
                    } else {
                        updateStatus(); 
                    }
                    isAITurn = false;
                }, 100);
            } else {
                isAITurn = false;
                drawBoard(true);
                updateStatus();
            }
        }
        
        function handleMove(r, c) {
            if (!isGameActive || currentPlayer === WHITE || isAITurn) return;

            const moveSuccessful = doMove(r, c, currentPlayer);

            if (moveSuccessful) {
                transpositionTable.clear(); 
                currentPlayer = 3 - currentPlayer;
                checkTurn();
            }
        }

        function initGame(isLearning = false) {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
            board[3][3] = WHITE;
            board[3][4] = BLACK;
            board[4][3] = BLACK;
            board[4][4] = WHITE;
            currentPlayer = BLACK;
            transpositionTable.clear();
            
            if (!isLearning) {
                isGameActive = true;
                drawBoard();
                updateStatus();
                learningInfoElement.textContent = `AIの学習が完了しました（探索時間 ${TIME_LIMIT/1000}秒）。プレイヤー（黒）の番です。`;
            }
        }
        
        function runLearning(iterations) {
            const LEARNING_RATE = 0.05;
            
            learningInfoElement.textContent = `AIが**${iterations}回**の自己対戦で学習中です... (0%)`;

            for (let i = 0; i < iterations; i++) {
                initGame(true);
                let history = []; 

                while (!isGameOver(board)) {
                    const move = getBestMove(board, currentPlayer, true); 
                    
                    if (move) {
                        history.push({ board: copyBoard(board), move: move, player: currentPlayer });
                        doMove(move.r, move.c, currentPlayer);
                        currentPlayer = 3 - currentPlayer;
                    } else {
                        currentPlayer = 3 - currentPlayer;
                    }
                }

                const winner = getWinner(board);
                const reward = (winner === BLACK) ? 1 : (winner === WHITE) ? -1 : 0; 

                for (const record of history) {
                    const state = record.board;
                    
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            if (state[r][c] === BLACK) {
                                evaluationWeights[r][c] += LEARNING_RATE * reward;
                            } else if (state[r][c] === WHITE) {
                                evaluationWeights[r][c] -= LEARNING_RATE * reward;
                            }
                        }
                    }
                }
                
                if ((i + 1) % (iterations / 10) === 0 || i === iterations - 1) {
                    learningInfoElement.textContent = `AIが**${iterations}回**の自己対戦で学習中です... (${Math.round(((i + 1) / iterations) * 100)}%)`;
                }
            }
            console.log("学習終了後の評価重み:", evaluationWeights);
        }

        // ページロード時の処理
        window.onload = function() {
            setTimeout(() => {
                runLearning(100); 
                
                initGame();
        
